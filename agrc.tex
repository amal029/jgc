
\subsection{AGRC analysis}
\label{sec:agrc-analysis}

In order to statically determine the worst case memory consumption of a
program targeting TP-JOP, one needs to analyze codes generated from both
CNs and JDNs. The compiler is able to trivially determine the maximum
memory footprint required for executing CN codes from any given SystemJ
programs [] since there is no dynamic memory allocation required for
executing this code. On the other hand, the data-flow analysis for JDNs
is more intricate since it needs to analyze the original AGRC in order
to retrieve the dependency edges, which are lost after splitting CNs and
JDNs from the AGRC. We devote this section to illustrate this analysis
technique.

AGRC is a \textit{directed graph} of tuple $G =(V,E)$, where $V$ is the
set of vertices (nodes of AGRC) and $E$ is the set of ordered pairs of
vertices. Each edge $e = (v_i,v_j), \forall e \in E$ is a tuple denoting
that the edge is directed from $v_i$ to $v_j$. Then a function
$\lambda:v \rightarrow E_i$, $E_i \subseteq E$, maps \textit{each}
vertex to a set of edge(s) where $\forall (v_i,v_j) \in E_i, v_j = v$
and $E_i$ can be $\emptyset$. When $|E_i| = 1$ we call $v_i$
\textit{must} be called before $v$ whereas when $|E_i| > 1$ we call any
$v_i \in E_i$ \textit{may} be called before $v$.

The algorithm for obtaining \textit{may} and \textit{must} relationships
of the nodes in AGRC is shown in Algorithm~??. The input to algorithm is
an AGRC  

%Give formal definition of may and must. Then describe the algorithm that
%given a method, the callee method, gives the may and must caller
%methods.
